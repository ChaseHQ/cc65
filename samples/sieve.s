;
; File generated by cc65 v 2.19 - Git e95db437a
;
	.fopt		compiler,"cc65 v 2.19 - Git e95db437a"
	.setcpu		"6502"
	.smart		on
	.autoimport	on
	.case		on
	.debuginfo	on
	.importzp	sp, sreg, regsave, regbank
	.importzp	tmp1, tmp2, tmp3, tmp4, ptr1, ptr2, ptr3, ptr4
	.macpack	longbranch
	.dbg		file, "sieve.c", 2999, 1657744212
	.dbg		file, "/cygdrive/c/Users/Craig Vella/Documents/GitHub/cc65/include/stdlib.h", 6145, 1657744211
	.dbg		file, "/cygdrive/c/Users/Craig Vella/Documents/GitHub/cc65/include/stdio.h", 6901, 1657744211
	.dbg		file, "/cygdrive/c/Users/Craig Vella/Documents/GitHub/cc65/include/ctype.h", 4573, 1657744211
	.dbg		file, "/cygdrive/c/Users/Craig Vella/Documents/GitHub/cc65/include/time.h", 5386, 1657744211
	.dbg		file, "/cygdrive/c/Users/Craig Vella/Documents/GitHub/cc65/include/conio.h", 9248, 1657744211
	.dbg		file, "/cygdrive/c/Users/Craig Vella/Documents/GitHub/cc65/include/stdarg.h", 2970, 1657744211
	.dbg		file, "/cygdrive/c/Users/Craig Vella/Documents/GitHub/cc65/include/target.h", 3121, 1657744211
	.dbg		file, "/cygdrive/c/Users/Craig Vella/Documents/GitHub/cc65/include/cbm.h", 12209, 1657744211
	.dbg		file, "/cygdrive/c/Users/Craig Vella/Documents/GitHub/cc65/include/stddef.h", 3127, 1657744211
	.dbg		file, "/cygdrive/c/Users/Craig Vella/Documents/GitHub/cc65/include/c64.h", 7085, 1657744211
	.dbg		file, "/cygdrive/c/Users/Craig Vella/Documents/GitHub/cc65/include/_vic2.h", 11027, 1657744211
	.dbg		file, "/cygdrive/c/Users/Craig Vella/Documents/GitHub/cc65/include/_sid.h", 3694, 1657744211
	.dbg		file, "/cygdrive/c/Users/Craig Vella/Documents/GitHub/cc65/include/_6526.h", 4033, 1657744211
	.dbg		file, "/cygdrive/c/Users/Craig Vella/Documents/GitHub/cc65/include/cbm_filetype.h", 5057, 1657744211
	.forceimport	__STARTUP__
	.dbg		sym, "printf", "00", extern, "_printf"
	.dbg		sym, "toupper", "00", extern, "_toupper"
	.dbg		sym, "clock", "00", extern, "_clock"
	.dbg		sym, "kbhit", "00", extern, "_kbhit"
	.dbg		sym, "cgetc", "00", extern, "_cgetc"
	.import		_printf
	.import		_toupper
	.import		_clock
	.import		_kbhit
	.import		_cgetc
	.export		_main

.segment	"RODATA"

S0002:
	.byte	$D3,$49,$45,$56,$45,$20,$42,$45,$4E,$43,$48,$4D,$41,$52,$4B,$20
	.byte	$2D,$20,$43,$41,$4C,$43,$55,$4C,$41,$54,$49,$4E,$47,$20,$50,$52
	.byte	$49,$4D,$45,$53,$0D,$00
S0008:
	.byte	$D1,$20,$54,$4F,$20,$51,$55,$49,$54,$2C,$20,$41,$4E,$59,$20,$4F
	.byte	$54,$48,$45,$52,$20,$4B,$45,$59,$20,$43,$4F,$4E,$54,$49,$4E,$55
	.byte	$45,$53,$0D,$00
S0006:
	.byte	$D1,$20,$54,$4F,$20,$51,$55,$49,$54,$2C,$20,$41,$4E,$59,$20,$4F
	.byte	$54,$48,$45,$52,$20,$4B,$45,$59,$20,$46,$4F,$52,$20,$4C,$49,$53
	.byte	$54,$0D,$00
S0005:
	.byte	$D4,$49,$4D,$45,$20,$55,$53,$45,$44,$3A,$20,$25,$55,$2E,$25,$30
	.byte	$33,$55,$20,$53,$45,$43,$4F,$4E,$44,$53,$0D,$00
S0004:
	.byte	$D0,$4C,$45,$41,$53,$45,$20,$57,$41,$49,$54,$20,$50,$41,$54,$49
	.byte	$45,$4E,$54,$4C,$59,$20,$2E,$2E,$2E,$0D,$00
S0003:
	.byte	$42,$45,$54,$57,$45,$45,$4E,$20,$32,$20,$41,$4E,$44,$20,$25,$55
	.byte	$0D,$00
S0007:
	.byte	$25,$34,$44,$0D,$00

.segment	"BSS"

_Sieve:
	.res	16384,$00

; ---------------------------------------------------------------
; char __near__ ReadUpperKey (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_ReadUpperKey: near

	.dbg	func, "ReadUpperKey", "00", static, "_ReadUpperKey"

.segment	"CODE"

;
; return toupper (cgetc ());
;
	.dbg	line, "sieve.c", 48
	jsr     _cgetc
	jsr     _toupper
	ldx     #$00
;
; }
;
	.dbg	line, "sieve.c", 49
	rts

	.dbg	line
.endproc

; ---------------------------------------------------------------
; int __near__ main (void)
; ---------------------------------------------------------------

.segment	"CODE"

.proc	_main: near

	.dbg	func, "main", "00", extern, "_main"
	.dbg	sym, "S", "00", register, "regbank", 4
	.dbg	sym, "I", "00", register, "regbank", 2
	.dbg	sym, "J", "00", register, "regbank", 0

.segment	"CODE"

;
; register unsigned char* S;
;
	.dbg	line, "sieve.c", 61
	lda     regbank+4
	ldx     regbank+5
	jsr     pushax
;
; register unsigned       I;
;
	.dbg	line, "sieve.c", 62
	lda     regbank+2
	ldx     regbank+3
	jsr     pushax
;
; register unsigned       J;
;
	.dbg	line, "sieve.c", 63
	lda     regbank+0
	ldx     regbank+1
	jsr     pushax
;
; printf ("Sieve benchmark - calculating primes\n");
;
	.dbg	line, "sieve.c", 66
	lda     #<(S0002)
	ldx     #>(S0002)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; printf ("between 2 and %u\n", COUNT);
;
	.dbg	line, "sieve.c", 67
	lda     #<(S0003)
	ldx     #>(S0003)
	jsr     pushax
	ldx     #$40
	lda     #$00
	jsr     pushax
	ldy     #$04
	jsr     _printf
;
; printf ("Please wait patiently ...\n");
;
	.dbg	line, "sieve.c", 68
	lda     #<(S0004)
	ldx     #>(S0004)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; Ticks = clock();
;
	.dbg	line, "sieve.c", 71
	jsr     _clock
	sta     M0001
	stx     M0001+1
	ldy     sreg
	sty     M0001+2
	ldy     sreg+1
	sty     M0001+3
;
; I = 2;
;
	.dbg	line, "sieve.c", 74
	ldx     #$00
	lda     #$02
	sta     regbank+2
	stx     regbank+2+1
;
; while (I < SQRT_COUNT) {
;
	.dbg	line, "sieve.c", 75
	jmp     L0004
;
; if (Sieve[I] == 0) {
;
	.dbg	line, "sieve.c", 76
L0002:	lda     regbank+2
	sta     ptr1
	lda     regbank+2+1
	clc
	adc     #>(_Sieve)
	sta     ptr1+1
	ldy     #<(_Sieve)
	lda     (ptr1),y
	bne     L0008
;
; J = I*2;
;
	.dbg	line, "sieve.c", 78
	lda     regbank+2
	ldx     regbank+2+1
	stx     tmp1
	asl     a
	rol     tmp1
	ldx     tmp1
	sta     regbank+0
	stx     regbank+0+1
;
; S = &Sieve[J];
;
	.dbg	line, "sieve.c", 79
	clc
	adc     #<(_Sieve)
	sta     regbank+4
	txa
	adc     #>(_Sieve)
	sta     regbank+4+1
;
; while (J < COUNT) {
;
	.dbg	line, "sieve.c", 80
	jmp     L0009
;
; *S = 1;
;
	.dbg	line, "sieve.c", 81
L0007:	lda     #$01
	ldy     #$00
	sta     (regbank+4),y
;
; S += I;
;
	.dbg	line, "sieve.c", 82
	lda     regbank+2
	clc
	adc     regbank+4
	sta     regbank+4
	lda     regbank+2+1
	adc     regbank+4+1
	sta     regbank+4+1
;
; J += I;
;
	.dbg	line, "sieve.c", 83
	lda     regbank+2
	clc
	adc     regbank+0
	sta     regbank+0
	lda     regbank+2+1
	adc     regbank+0+1
	sta     regbank+0+1
;
; while (J < COUNT) {
;
	.dbg	line, "sieve.c", 80
L0009:	ldx     regbank+0+1
	cpx     #$40
	bcc     L0007
;
; ++I;
;
	.dbg	line, "sieve.c", 86
L0008:	inc     regbank+2
	bne     L0004
	inc     regbank+2+1
;
; while (I < SQRT_COUNT) {
;
	.dbg	line, "sieve.c", 75
L0004:	lda     regbank+2+1
	cmp     #$00
	bne     L0005
	lda     regbank+2
	cmp     #$80
L0005:	bcc     L0002
;
; Ticks = clock() - Ticks;
;
	.dbg	line, "sieve.c", 90
	jsr     _clock
	jsr     pusheax
	lda     M0001+3
	sta     sreg+1
	lda     M0001+2
	sta     sreg
	ldx     M0001+1
	lda     M0001
	jsr     tossubeax
	sta     M0001
	stx     M0001+1
	ldy     sreg
	sty     M0001+2
	ldy     sreg+1
	sty     M0001+3
;
; Sec = (unsigned) (Ticks / CLOCKS_PER_SEC);
;
	.dbg	line, "sieve.c", 91
	lda     M0001+3
	sta     sreg+1
	lda     M0001+2
	sta     sreg
	ldx     M0001+1
	lda     M0001
	jsr     pusheax
	ldx     #$00
	lda     #$3C
	jsr     tosudiv0ax
	sta     M0002
	stx     M0002+1
;
; Milli = ((Ticks % CLOCKS_PER_SEC) * 1000) / CLOCKS_PER_SEC;
;
	.dbg	line, "sieve.c", 92
	lda     M0001+3
	sta     sreg+1
	lda     M0001+2
	sta     sreg
	ldx     M0001+1
	lda     M0001
	jsr     pusheax
	ldx     #$00
	lda     #$3C
	jsr     tosumod0ax
	jsr     pusheax
	ldx     #$03
	lda     #$E8
	jsr     tosumul0ax
	jsr     pusheax
	ldx     #$00
	lda     #$3C
	jsr     tosudiv0ax
	sta     M0003
	stx     M0003+1
;
; printf ("Time used: %u.%03u seconds\n", Sec, Milli);
;
	.dbg	line, "sieve.c", 95
	lda     #<(S0005)
	ldx     #>(S0005)
	jsr     pushax
	lda     M0002
	ldx     M0002+1
	jsr     pushax
	lda     M0003
	ldx     M0003+1
	jsr     pushax
	ldy     #$06
	jsr     _printf
;
; printf ("Q to quit, any other key for list\n");
;
	.dbg	line, "sieve.c", 96
	lda     #<(S0006)
	ldx     #>(S0006)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; if (ReadUpperKey () != 'Q') {
;
	.dbg	line, "sieve.c", 99
	jsr     _ReadUpperKey
	cmp     #$D1
	beq     L000D
;
; J = 0;
;
	.dbg	line, "sieve.c", 101
	ldx     #$00
	txa
	sta     regbank+0
	sta     regbank+0+1
;
; for (I = 2; I < COUNT; ++I) {
;
	.dbg	line, "sieve.c", 102
	lda     #$02
	sta     regbank+2
	stx     regbank+2+1
L000C:	ldx     regbank+2+1
	cpx     #$40
	bcs     L000D
;
; if (Sieve[I] == 0) {
;
	.dbg	line, "sieve.c", 103
	lda     regbank+2
	sta     ptr1
	lda     regbank+2+1
	clc
	adc     #>(_Sieve)
	sta     ptr1+1
	ldy     #<(_Sieve)
	lda     (ptr1),y
	bne     L0012
;
; printf ("%4d\n", I);
;
	.dbg	line, "sieve.c", 104
	lda     #<(S0007)
	ldx     #>(S0007)
	jsr     pushax
	lda     regbank+2
	ldx     regbank+2+1
	jsr     pushax
	ldy     #$04
	jsr     _printf
;
; if (++J == 23) {
;
	.dbg	line, "sieve.c", 105
	inc     regbank+0
	bne     L0013
	inc     regbank+0+1
L0013:	lda     regbank+0+1
	bne     L0012
	lda     regbank+0
	cmp     #$17
	bne     L0012
;
; printf ("Q to quit, any other key continues\n");
;
	.dbg	line, "sieve.c", 106
	lda     #<(S0008)
	ldx     #>(S0008)
	jsr     pushax
	ldy     #$02
	jsr     _printf
;
; if (ReadUpperKey () == 'Q') {
;
	.dbg	line, "sieve.c", 107
	jsr     _ReadUpperKey
	cmp     #$D1
;
; break;
;
	.dbg	line, "sieve.c", 108
	beq     L000D
;
; J = 0;
;
	.dbg	line, "sieve.c", 110
	lda     #$00
	sta     regbank+0
	sta     regbank+0+1
;
; if (kbhit() && ReadUpperKey () == 'Q') {
;
	.dbg	line, "sieve.c", 113
L0012:	jsr     _kbhit
	tax
	beq     L000E
	jsr     _ReadUpperKey
	cmp     #$D1
	beq     L000D
;
; for (I = 2; I < COUNT; ++I) {
;
	.dbg	line, "sieve.c", 102
L000E:	inc     regbank+2
	bne     L000C
	inc     regbank+2+1
	jmp     L000C
;
; return EXIT_SUCCESS;
;
	.dbg	line, "sieve.c", 119
L000D:	ldx     #$00
	txa
;
; }
;
	.dbg	line, "sieve.c", 120
	pha
	tay
L001A:	lda     (sp),y
	sta     regbank+0,y
	iny
	cpy     #$06
	bne     L001A
	pla
	jmp     incsp6

	.dbg	line
.segment	"BSS"

M0001:
	.res	4,$00
M0002:
	.res	2,$00
M0003:
	.res	2,$00

.endproc

